\chapter{Odoo Sous Docker}

	Dans ce qui suit, nous allons donner une idée sur l'interface que fournit Docker pour la provision des services (conteneurs). Nous allons réalisé la mini-architecture suivante:
	
	\begin{figure}[H]
	\centering
	\includegraphics [scale=0.5]{biblio/odoo.jpg}
	\caption{Odoo sous Docker}
	\label{fig:}
	\end{figure}

\section*{Environnement technique}
	
	On va partir d'un serveur Ubuntu 14.04-64 bits avec Docker installé (L'installation ne sera pas détaillé), ou de préférence, un serveur CoreOS où Docker est déja inclut avec ce système d'éxploitation. A noter que Docker nécéssite un linux 64 bits avec un noyau >= 3.8.


\section*{Installation de PostgreSQL}

	Odoo a besoin d'un serveur de base de donnée PostgreSQL, la commande suivante permet de l'installer:

	\begin{lstlisting}[caption=Installation de PostgreSQL]
		$ docker run -d -e POSTGRES_USER=odoo -e POSTGRES_PASSWORD=odoo --name db postgres
	\end{lstlisting}




\section*{Installation d'Odoo}

	L'installation d'Odoo se fait grâce à la commande suivante:
	\begin{lstlisting}[language=bash,caption=Installation d'Odoo]
		$ docker run -p 80:8069 --name odoo --link db:db -t odoo
	\end{lstlisting}

	En quelques secondes, on pu lancer le service Odoo prêt à être utilisé, personnalisé, et éventuellement porté vers un autre serveur. Pour accéder au service il suffit de taper dans le navigateur:

	\begin{lstlisting}[language=bash]
		http://IP_SERVEUR:80
	\end{lstlisting}

	




\chapter{Docker-compose}

	On va réaliser l'installation détaillé dans \emph{l'Annexe A} avec l'outil \emph{Docker-compose}. Cet outil permet de définir dans un fichier \acrshort{yaml} l'architecture de l'application. Enfin, on peut faire des manipulation (démarrage, redémarrage, arrêt) sur toute l'architecture comme si c'était un seul service.

	\begin{lstlisting}[language=bash,caption=Installation d'Odoo avec Docker-compose]
		odoo:
	  		image: odoo
		  	links:
		   		- db
		  	ports:
		   		- "80:8069"
		db:
		  	image: postgres
		  	environment:
  				- POSTGRES_USER: odoo
  				- POSTGRES_PASSWORD: odoo
	\end{lstlisting}

	\begin{lstlisting}[language=bash,caption=Lancement d'Odoo avec Docker-compose]
		$ docker-compose up -d
	\end{lstlisting}


\chapter{Installation de la PaaS Deis}

	\begin{lstlisting}[language=bash,caption=Génération de la clé privée eet la certificat]
		$ openssl genrsa -des3 -passout pass:x -out server.pass.key 2048
		$ openssl rsa -passin pass:x -in server.pass.key -out server.key
		$ openssl req -new -key server.key -out server.csr
		$ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
	\end{lstlisting}

	\begin{lstlisting}[language=bash,caption=Activation du protocole SSL]
		$ deisctl config router set sslKey=server.key sslCert=server.crt
		$ deisctl config router set enforceHTTPS=true
	\end{lstlisting}	

\chapter{Douze-facteurs d'un SaaS}
\label{annexe:12factors}

Dans l'informatique moderne, le logiciel est généralement livré comme un service: appelés \acrshort{saas}. Les douze-facteurs d'un SaaS est une méthodologie pour la création d'application qui:

\begin{itemize}
	\item Réduit le temps et le coût pour les nouveaux développeurs participant au projet;
	\item offre une \textbf{portabilité maximale} entre les environnements d'exécution;
	\item Sont appropriées pour le \textbf{déploiement} sur les \textbf{plates-formes de cloud} modernes, éliminant ainsi la nécessité de serveurs et d'administration de systèmes;
	\item \textbf{Réduit la divergence} entre le développement et la production, permettant un déploiement continu;
	\item peut \textbf{monter en charge} sans toucher aux outils, à l'architecture, ou à les pratiques de développement.
\end{itemize}


La méthodologie des douze-facteurs synthétise l'éxpérience de l'équipe de Heroku, un des tout premiers services cloud \cite{12-factors}. Elles peut être appliquée à des applications écrites dans n'importe quel langage de programmation, et qui sont combinées à n'importe quel services (base de données, file d'attente, mémoire cache, etc.).


\section*{code source}

Le code source de l'application doit être unique mis et suivi depuis un système de contrôle de version comme Git.

\section*{Dépendances}

La plupart des langages de programmation un sytème de gestion de dépendances. Ainsi, une application doit déclarer explicitement et isoler les dépendances. Un SaaS robuste ne repose jamais sur l'éxistence implicite des dépendances. 

\section*{Configuration}

Les variables de configurations peuvent varier entre les environnements (développement, test, production, etc). Ces variables ne doivent jamais être stockées dans des constantes à l'intérieur du code. Une bonne pratique c'est les stocker dans des variables d'environnement.

\section*{Services de support}

Traiter tous les services de support (base de données, file d'attente, serveur \acrshort{smtp}, etc.)  comme des ressources liées.

\section*{Build, release, run}

Pour déployer une application, il faut passer par trois étapes:
\begin{itemize}
	\item build: transformer le code source en exécutable;
	\item release: combiner l'exécutable avec les configurations;
	\item run: lancer les processus dans l'environnement d'exécution .
\end{itemize}


\section*{Processus}

Les processus d'une application doivent être \textbf{sans état} (stateless). Les données persistentes doivent être stockées dans une base de donnée.

\section*{Attachement de port}

Chaque service doit être exporté via un port.

\section*{Concurrence}

Les processus d'une application ne doivent jamais lancés comme un démon. Au lieu de cela,il faut compter sur le gestionnaire de processus du système d'exploitation (systemd, init.d, upstart, etc.).

\section*{Jetable}

Les processus d'une application sont jetables, ils peuvent être stoppés ou démarrés à n'importe quel moment rapidement et sans causer de problèmes.

\section*{Parité Dev/Prod}

Il faut garder tous les environnements (développement, test, production, etc) similaires.

\section*{Messages logs}

Les messages logs sont très importants, il faut les traiter comme des flux d'événements.

\section*{Processus admin}

Les taches d'administration doivent être exécutés dans un unique processus avec un environnement identique à celui du processus principal.